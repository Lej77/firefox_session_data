import type { ContextOptions as WasmContextOptions } from "../../wasi-snapshot-preview1.ts";
import type {
  MessageFromWorker,
  WasmCommandResult,
  WasmCommandRunOptions,
} from "./common.ts";
import { messageToWorker, withStdioStringMethods } from "./common.ts";

// Bundled code was generated by:
// 1. Inline all imported modules (recursively) into `background.ts`
// 2. Compile the TypeScript code to JavaScript using
//    https://www.typescriptlang.org/play/?removeComments=true&target=11
//    - Also remove all comments to be safe.
// 3. Manually rewrite all backtick (``) strings into other kinds of string.
// 4. Ensure all backslashes are double escaped (search and replace \ with \\).
// 5. Surround the code with backticks to turn it into a multi line string.
import { CODE as BUNDLED_CODE } from "./background-bundled.js";

const BUNDLED_BLOB = new Blob([BUNDLED_CODE], {
  type: "application/javascript",
});
const BUNDLED_URL = URL.createObjectURL(BUNDLED_BLOB);

export interface CreateWorkerOptions {
  wasmContextOptions: WasmContextOptions;
  wasmData: Uint8Array;
}
export class WasmCommandWorker {
  private startOptions: CreateWorkerOptions;
  private worker: Worker | null = null;
  private onWorkerMessage: (msg: MessageEvent<MessageFromWorker>) => void;
  private isDisposed = false;

  private resolveCommand: null | ((result: WasmCommandResult) => void) = null;
  private rejectCommand: null | ((error: Error) => void) = null;
  private onStderrLine: null | ((line: string) => void) = null;

  private constructor(options: CreateWorkerOptions) {
    this.startOptions = options;
    this.onWorkerMessage = this._onWorkerMessage.bind(this);

    // Ensure we have permissions to start workers:
    WasmCommandWorker.startWorker(options).terminate();
  }

  public static create(options: CreateWorkerOptions) {
    return new WasmCommandWorker(options);
  }

  private static startWorker(options: CreateWorkerOptions) {
    //const worker = new Worker(new URL("./background.ts", import.meta.url).href, { type: "module" },);
    //const worker = new Worker('data:,' + BUNDLED_CODE, { type: 'module' })

    const worker = new Worker(BUNDLED_URL, { type: "module" });

    worker.postMessage(
      messageToWorker({
        type: "wasm-init",
        context: options.wasmContextOptions,
        wasmData: options.wasmData,
      }),
    );
    return worker;
  }

  public restartWorker() {
    if (this.isDisposed) {
      throw new Error(
        `WasmCommandWorker can't be used after it has been disposed`,
      );
    }
    this.terminateWorker();

    this.worker = WasmCommandWorker.startWorker(this.startOptions);
    this.worker.addEventListener("message", this.onWorkerMessage);
  }
  private clearCommandCallbacks() {
    this.rejectCommand = null;
    this.resolveCommand = null;
    this.onStderrLine = null;
  }
  public terminateWorker() {
    this.worker?.terminate();
    this.worker = null;

    this.rejectCommand?.(new Error("Wasm command worker was disposed"));
    this.clearCommandCallbacks();
  }
  private ensureWorker(): Worker {
    if (this.worker !== null) {
      return this.worker;
    }
    this.restartWorker();
    return this.worker!;
  }

  private _onWorkerMessage(msg: MessageEvent<MessageFromWorker>) {
    switch (msg.data.type) {
      case "command-success":
        this.resolveCommand?.(withStdioStringMethods(msg.data.result));
        this.clearCommandCallbacks();
        this.terminateWorker();
        break;
      case "command-failed":
        this.rejectCommand?.(new Error(msg.data.error));
        this.clearCommandCallbacks();
        this.terminateWorker();
        break;
      case "stderr-line":
        this.onStderrLine?.(msg.data.line);
        break;
      default: {
        const _exhaustive: never = msg.data;
      }
    }
  }

  public run(
    options: WasmCommandRunOptions,
  ): Promise<WasmCommandResult> {
    return new Promise((resolve, reject) => {
      if (this.resolveCommand) {
        // TODO: option to wait for previous command to finish instead of canceling it.
        this.terminateWorker();
      }
      const worker = this.ensureWorker();
      worker.postMessage(messageToWorker({
        type: "run-command",
        options,
        sendStderrLines: Boolean(options.onStderrLine),
      }));

      this.resolveCommand = resolve;
      this.rejectCommand = reject;
      this.onStderrLine = options.onStderrLine ?? null;
    });
  }

  [Symbol.dispose]() {
    this.terminateWorker();
    this.isDisposed = true;
  }
}
